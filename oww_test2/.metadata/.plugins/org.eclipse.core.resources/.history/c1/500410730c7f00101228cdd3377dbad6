package oww.banking.controller;

import java.util.Base64;
import java.util.HashMap;
import java.util.Map;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.http.HttpStatus;
import org.springframework.http.ResponseEntity;
import org.springframework.security.core.Authentication;
import org.springframework.stereotype.Controller;
import org.springframework.ui.Model;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.ResponseBody;

import com.fasterxml.jackson.databind.ObjectMapper;

import jakarta.servlet.http.Cookie;
import jakarta.servlet.http.HttpServletRequest;
import oww.banking.service.AccountService;
import oww.banking.vo.AccountVO;

@Controller
public class TransferController {

	@Autowired
	private AccountService accountService;

	private ObjectMapper objectMapper = new ObjectMapper();

	/**
	 * JWT 토큰에서 사용자 정보 추출 (토큰 기반 인증)
	 */
	private Map<String, Object> extractUserInfoFromToken(HttpServletRequest request) {
		Map<String, Object> userInfo = new HashMap<>();

		try {
			// 1. 쿠키에서 JWT 토큰 추출
			String token = null;
			Cookie[] cookies = request.getCookies();
			if (cookies != null) {
				for (Cookie cookie : cookies) {
					if ("jwt-token".equals(cookie.getName())) {
						token = cookie.getValue();
						break;
					}
				}
			}

			// 2. Authorization 헤더에서도 확인 (Bearer 토큰)
			if (token == null) {
				String authHeader = request.getHeader("Authorization");
				if (authHeader != null && authHeader.startsWith("Bearer ")) {
					token = authHeader.substring(7);
				}
			}

			if (token == null) {
				userInfo.put("authenticated", false);
				userInfo.put("message", "토큰이 없습니다.");
				return userInfo;
			}

			// 3. JWT 토큰 파싱 (payload 추출)
			String[] tokenParts = token.split("\\.");
			if (tokenParts.length != 3) {
				userInfo.put("authenticated", false);
				userInfo.put("message", "유효하지 않은 토큰 형식입니다.");
				return userInfo;
			}

			// 4. Base64 디코딩으로 payload 추출
			String payload = new String(Base64.getUrlDecoder().decode(tokenParts[1]));
			Map<String, Object> payloadMap = objectMapper.readValue(payload, Map.class);

			// 5. 토큰 만료 확인
			Integer exp = (Integer) payloadMap.get("exp");
			if (exp != null) {
				long currentTime = System.currentTimeMillis() / 1000;
				if (currentTime >= exp) {
					userInfo.put("authenticated", false);
					userInfo.put("message", "토큰이 만료되었습니다.");
					return userInfo;
				}
			}

			// 6. 사용자 정보 추출
			userInfo.put("authenticated", true);
			userInfo.put("userNo", payloadMap.get("userNo"));
			userInfo.put("userName",
					payloadMap.get("username") != null ? payloadMap.get("username") : payloadMap.get("name"));
			userInfo.put("userEmail",
					payloadMap.get("email") != null ? payloadMap.get("email") : payloadMap.get("sub"));
			userInfo.put("userRole", payloadMap.get("role"));

			System.out.println("토큰 기반 인증 성공: " + userInfo.get("userName"));

		} catch (Exception e) {
			System.out.println("토큰 파싱 오류: " + e.getMessage());
			e.printStackTrace();
			userInfo.put("authenticated", false);
			userInfo.put("message", "토큰 처리 중 오류가 발생했습니다.");
		}

		return userInfo;
	}

	/**
	 * 토큰 기반 사용자 정보를 Model에 추가
	 */
	private void addUserInfoToModel(Model model, HttpServletRequest request) {
		Map<String, Object> userInfo = extractUserInfoFromToken(request);

		model.addAttribute("isAuthenticated", userInfo.get("authenticated"));
		model.addAttribute("userNo", userInfo.get("userNo"));
		model.addAttribute("userName", userInfo.get("userName"));
		model.addAttribute("userEmail", userInfo.get("userEmail"));
		model.addAttribute("userRole", userInfo.get("userRole"));
	}

	/**
	 * 계좌 정보 API (완전한 토큰 기반)
	 */
	@GetMapping(value = "/api/account", produces = "application/json")
	@ResponseBody
	public ResponseEntity<Map<String, Object>> getAccountInfoApi(Authentication authentication) {
		Map<String, Object> response = new HashMap<>();

		System.out.println("=== /api/account 요청 수신 ===");
		System.out.println("Authentication: " + (authentication != null ? authentication.getName() : "null"));

		try {
			if (authentication == null || !authentication.isAuthenticated()) {
				response.put("success", false);
				response.put("message", "인증이 필요합니다.");
				return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
			}

			String username = authentication.getName(); // JWT에서 추출된 사용자명

			response.put("success", true);
			response.put("userName", username);
			response.put("userEmail", username); // 일단 username을 email로 사용

			// 계좌 정보 조회
			AccountVO account = accountService.getAccountByEmail(username);
			if (account != null) {
				response.put("hasAccount", true);
				response.put("accountNumber", account.getAccountNumber());
				response.put("balance", account.getBalance());
			} else {
				response.put("hasAccount", false);
			}

			// 세이프박스는 일단 false로
			response.put("hasSafebox", false);
			response.put("safeboxBalance", 0);

			return ResponseEntity.ok(response);

		} catch (Exception e) {
			System.out.println("계좌 정보 조회 중 오류: " + e.getMessage());
			e.printStackTrace();

			response.put("success", false);
			response.put("message", "서버 오류가 발생했습니다.");
			return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);
		}
	}

	/**
	 * 계좌 생성 페이지 (토큰 기반)
	 */
	@GetMapping("/banking/createAccount")
	public String createAccount(Model model, HttpServletRequest request) {
		System.out.println("계좌 생성 페이지 호출됨");

		addUserInfoToModel(model, request);

		if (!(Boolean) model.getAttribute("isAuthenticated")) {
			System.out.println("토큰 기반 인증 실패 - 메인으로 리다이렉트");
			return "redirect:/main";
		}

		// 이미 계좌가 있는지 확인
		String userEmail = (String) model.getAttribute("userEmail");
		if (userEmail != null && accountService.isAccountExists(userEmail)) {
			model.addAttribute("errorMessage", "이미 계좌가 존재합니다.");
			return "redirect:/main";
		}

		return "banking_createAccount";
	}

	/**
	 * 이메일 인증번호 발송 (토큰 기반)
	 */
	@PostMapping("/banking/account/send-verification")
	@ResponseBody
	public ResponseEntity<Map<String, Object>> sendEmailVerification(@RequestParam("email") String email,
			HttpServletRequest request) {

		Map<String, Object> response = new HashMap<>();

		try {
			// 토큰 기반 인증 확인
			Map<String, Object> userInfo = extractUserInfoFromToken(request);

			if (!(Boolean) userInfo.get("authenticated")) {
				response.put("success", false);
				response.put("message", userInfo.get("message"));
				return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
			}

			// 이메일 유효성 검사
			if (email == null || !email.contains("@")) {
				response.put("success", false);
				response.put("message", "유효한 이메일 주소를 입력하세요.");
				return ResponseEntity.badRequest().body(response);
			}

			/*
			 * // 로그인한 사용자의 이메일과 일치하는지 확인 String userEmail = (String)
			 * userInfo.get("userEmail"); if (userEmail != null && !userEmail.equals(email))
			 * { response.put("success", false); response.put("message",
			 * "로그인한 계정의 이메일과 일치하지 않습니다."); return
			 * ResponseEntity.badRequest().body(response); }
			 */

			// 이미 계좌가 존재하는지 확인
			if (accountService.isAccountExists(email)) {
				response.put("success", false);
				response.put("message", "이미 계좌가 존재하는 이메일입니다.");
				return ResponseEntity.badRequest().body(response);
			}

			// 인증번호 발송
			String result = accountService.sendEmailVerification(email);

			response.put("success", true);
			response.put("message", result);
			return ResponseEntity.ok(response);

		} catch (Exception e) {
			System.out.println("인증번호 발송 오류: " + e.getMessage());
			e.printStackTrace();

			response.put("success", false);
			response.put("message", "인증번호 발송 중 오류가 발생했습니다.");
			return ResponseEntity.internalServerError().body(response);
		}
	}

	/**
	 * 이메일 인증번호 확인 (토큰 기반)
	 */
	@PostMapping("/banking/account/verify-email")
	@ResponseBody
	public ResponseEntity<Map<String, Object>> verifyEmailCode(@RequestParam("email") String email,
			@RequestParam("code") String code, Authentication authentication) {

		Map<String, Object> response = new HashMap<>();

		try {
			if (authentication == null || !authentication.isAuthenticated()) {
				response.put("success", false);
				response.put("message", "인증이 필요합니다.");
				return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
			}

			// 이메일 인증번호 확인
			boolean isValid = accountService.verifyEmailCode(email, code);

			if (isValid) {
				response.put("success", true);
				response.put("message", "인증번호가 확인되었습니다.");
			} else {
				response.put("success", false);
				response.put("message", "인증번호가 올바르지 않습니다.");
			}

			return ResponseEntity.ok(response);

		} catch (Exception e) {
			System.out.println("인증번호 확인 오류: " + e.getMessage());
			e.printStackTrace();

			response.put("success", false);
			response.put("message", "인증번호 확인 중 오류가 발생했습니다.");
			return ResponseEntity.internalServerError().body(response);
		}
	}

	/**
	 * 계좌 생성 (토큰 기반)
	 */
	@PostMapping("/banking/account/create")
	@ResponseBody
	public ResponseEntity<Map<String, Object>> createAccount(@RequestParam("name") String name,
			@RequestParam("email") String email, @RequestParam("password") String password,
			@RequestParam("emailCode") String emailCode, Authentication authentication) {

		Map<String, Object> response = new HashMap<>();

		try {
			if (authentication == null || !authentication.isAuthenticated()) {
				response.put("success", false);
				response.put("message", "인증이 필요합니다.");
				return ResponseEntity.status(HttpStatus.UNAUTHORIZED).body(response);
			}

			// 계좌 생성 서비스 호출
			String result = accountService.createAccount(name, email, password, emailCode);

			if (result.contains("성공적으로")) {
				response.put("success", true);
				response.put("message", result);
			} else {
				response.put("success", false);
				response.put("message", result);
			}

			return ResponseEntity.ok(response);

		} catch (Exception e) {
			System.out.println("계좌 생성 오류: " + e.getMessage());
			e.printStackTrace();

			response.put("success", false);
			response.put("message", "계좌 생성 중 오류가 발생했습니다.");
			return ResponseEntity.internalServerError().body(response);
		}
	}
	
	/**
	 * 계좌 생성 성공 페이지
	 */
	@GetMapping("/banking/account/success")
	public String accountSuccess(Model model, HttpServletRequest request) {
	    
	    // 토큰에서 사용자 정보 추출 (기존 extractUserInfoFromToken 메서드 활용)
	    Map<String, Object> userInfo = extractUserInfoFromToken(request);
	    
	    if (!(Boolean) userInfo.get("authenticated")) {
	        return "redirect:/banking/main";
	    }
	    
	    String userName = (String) userInfo.get("userName");
	    String userEmail = (String) userInfo.get("userEmail");
	    
	    System.out.println("Success 페이지 - userName: " + userName);
	    System.out.println("Success 페이지 - userEmail: " + userEmail);
	    
	    // userEmail이 실제 이메일이 아니라면 userNo로 찾기
	    AccountVO newAccount = null;
	    
	    if (userEmail != null && userEmail.contains("@")) {
	        // 이메일이 유효하면 이메일로 조회
	        newAccount = accountService.getAccountByEmail(userEmail);
	    } else {
	        // userNo로 조회
	        Integer userNo = (Integer) userInfo.get("userNo");
	        if (userNo != null) {
	            newAccount = accountService.findAccountByUserNo(userNo);
	        }
	    }
	    
	    System.out.println("조회된 계좌: " + (newAccount != null ? newAccount.getAccountNumber() : "null"));
	    
	    model.addAttribute("userName", userName);
	    model.addAttribute("newAccount", newAccount);
	    
	    return "account_success";
	}
	

	/**
	 * Banking 메인 페이지 (토큰 기반)
	 */
	@GetMapping("/banking/main")
	public String bankingMain(Model model, HttpServletRequest request) {
	    System.out.println("Banking Main 호출됨");

	    // 토큰 기반 사용자 정보 추출
	    Map<String, Object> userInfo = extractUserInfoFromToken(request);
	    
	    if (!(Boolean) userInfo.get("authenticated")) {
	        return "redirect:/"; // 인증되지 않은 경우 메인으로
	    }

	    String userName = (String) userInfo.get("userName");
	    Integer userNo = (Integer) userInfo.get("userNo");
	    
	    model.addAttribute("userName", userName);

	    // 계좌 정보 조회
	    if (userNo != null) {
	        AccountVO account = accountService.findAccountByUserNo(userNo);
	        if (account != null) {
	            model.addAttribute("hasAccount", true);
	            model.addAttribute("accountNumber", account.getAccountNumber());
	            model.addAttribute("balance", account.getBalance());
	        } else {
	            model.addAttribute("hasAccount", false);
	        }
	    }

	    return "banking_main";
	}
	
	

	/**
	 * 헬스체크 엔드포인트 (인증 불필요)
	 */
	@GetMapping("/health")
	@ResponseBody
	public ResponseEntity<String> health() {
		return ResponseEntity.ok("Banking Service is running on port 8203 - Token Based Auth");
	}
}