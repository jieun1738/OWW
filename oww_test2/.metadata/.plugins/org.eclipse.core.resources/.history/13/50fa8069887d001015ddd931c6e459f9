package com.oww.gateway.filter;

import com.oww.gateway.util.JwtUtil;
import org.springframework.cloud.gateway.filter.GatewayFilter;
import org.springframework.cloud.gateway.filter.factory.AbstractGatewayFilterFactory;
import org.springframework.http.HttpHeaders;
import org.springframework.http.HttpStatus;
import org.springframework.http.server.reactive.ServerHttpRequest;
import org.springframework.stereotype.Component;
import org.springframework.web.server.ServerWebExchange;
import reactor.core.publisher.Mono;

@Component
public class JwtAuthenticationGatewayFilterFactory extends AbstractGatewayFilterFactory<JwtAuthenticationGatewayFilterFactory.Config> {

    private final JwtUtil jwtUtil;

    public JwtAuthenticationGatewayFilterFactory(JwtUtil jwtUtil) {
        super(Config.class);
        this.jwtUtil = jwtUtil;
    }

    @Override
    public GatewayFilter apply(Config config) {
        return (exchange, chain) -> {
            System.out.println("[JWT Filter] 인증 필터 시작");
            
            ServerHttpRequest request = exchange.getRequest();
            String requestPath = request.getPath().toString();
            System.out.println("[JWT Filter] 요청 경로: " + requestPath);

            // JWT 토큰 추출 (쿠키 우선, 헤더 대안)
            String jwtToken = extractJwtToken(request);
            
            if (jwtToken == null) {
                System.out.println("[JWT Filter] JWT 토큰이 없음 - 로그인 페이지로 리다이렉트");
                return redirectToLogin(exchange);
            }

            try {
                // 토큰 검증 및 사용자 정보 추출 (한번에 처리)
                JwtUtil.TokenValidationResult validationResult = jwtUtil.validateTokenWithDetails(jwtToken);
                
                if (!validationResult.isValid()) {
                    System.out.println("[JWT Filter] JWT 토큰 검증 실패: " + validationResult.getMessage());
                    return redirectToLogin(exchange);
                }

                String username = validationResult.getUsername();
                String userNo = validationResult.getUserNo();
                String role = validationResult.getRole();

                System.out.println("[JWT Filter] JWT 토큰 검증 성공");
                System.out.println("   - Username: " + username);
                System.out.println("   - Role: " + role);
                System.out.println("   - UserNo: " + userNo);

                // 다운스트림 서비스로 전달할 헤더 추가 (표준화된 헤더명)
                ServerWebExchange mutatedExchange = exchange.mutate()
                        .request(r -> r.header("Authorization", "Bearer " + jwtToken)
                                .header("x-user-no", userNo != null ? userNo : "")           // 소문자 통일
                                .header("x-username", username != null ? username : "")      // 소문자 통일  
                                .header("x-user-role", role != null ? ("ROLE_" + role) : "ROLE_USER")  // ROLE_ 접두사 추가
                                .header("x-user-email", username != null ? username : ""))   // 이메일도 전달
                        .build();

                System.out.println("[JWT Filter] 헤더 추가 완료 - 다운스트림 서비스로 요청 전달");
                System.out.println("   - 대상 서비스: " + request.getURI());

                return chain.filter(mutatedExchange);

            } catch (Exception e) {
                System.err.println("[JWT Filter] JWT 토큰 처리 중 예외 발생: " + e.getMessage());
                e.printStackTrace();
                return redirectToLogin(exchange);
            }
        };
    }

    /**
     * JWT 토큰 추출 (쿠키 우선, Authorization 헤더 대안)
     */
    private String extractJwtToken(ServerHttpRequest request) {
        // 1. 쿠키에서 jwt-token 확인
        String cookieToken = request.getCookies()
                .getFirst("jwt-token") != null ?
                request.getCookies()
                        .getFirst("jwt-token")
                        .getValue() : null;

        if (cookieToken != null && !cookieToken.trim().isEmpty()) {
            System.out.println("[JWT Filter] 쿠키에서 JWT 토큰 발견");
            return cookieToken.trim();
        }

        // 2. Authorization 헤더에서 확인
        String authHeader = request.getHeaders().getFirst(HttpHeaders.AUTHORIZATION);
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String token = authHeader.substring(7).trim();
            if (!token.isEmpty()) {
                System.out.println("[JWT Filter] Authorization 헤더에서 JWT 토큰 발견");
                return token;
            }
        }

        System.out.println("[JWT Filter] JWT 토큰을 찾을 수 없음 (쿠키, 헤더 모두 없음)");
        return null;
    }

    /**
     * 로그인 페이지로 리다이렉트
     */
    private Mono<Void> redirectToLogin(ServerWebExchange exchange) {
        String originalPath = exchange.getRequest().getPath().toString();
        String redirectUrl = "/auth/oauth2/authorization/google";
        
        // API 요청인 경우 JSON 에러 응답
        if (originalPath.startsWith("/api/")) {
            return createJsonErrorResponse(exchange, "Authentication required", HttpStatus.UNAUTHORIZED);
        }
        
        // 일반 페이지 요청인 경우 로그인 페이지로 리다이렉트
        System.out.println("[JWT Filter] 로그인 페이지로 리다이렉트: " + redirectUrl);
        
        exchange.getResponse().setStatusCode(HttpStatus.FOUND);
        exchange.getResponse().getHeaders().add("Location", redirectUrl);
        return exchange.getResponse().setComplete();
    }

    /**
     * JSON 에러 응답 (API 요청용)
     */
    private Mono<Void> createJsonErrorResponse(ServerWebExchange exchange, String errorMessage, HttpStatus status) {
        System.out.println("[JWT Filter] JSON 에러 응답: " + errorMessage);
        
        exchange.getResponse().setStatusCode(status);
        exchange.getResponse().getHeaders().add("Content-Type", "application/json");

        String body = String.format(
            "{\"success\": false, \"error\": \"%s\", \"message\": \"%s\", \"timestamp\": \"%s\"}",
            status.getReasonPhrase(), errorMessage, java.time.Instant.now()
        );

        return exchange.getResponse().writeWith(
                Mono.just(exchange.getResponse().bufferFactory().wrap(body.getBytes()))
        );
    }

    public static class Config {
        private boolean redirectOnFailure = true;
        private boolean debugMode = false;
        
        public boolean isRedirectOnFailure() {
            return redirectOnFailure;
        }
        
        public void setRedirectOnFailure(boolean redirectOnFailure) {
            this.redirectOnFailure = redirectOnFailure;
        }
        
        public boolean isDebugMode() {
            return debugMode;
        }
        
        public void setDebugMode(boolean debugMode) {
            this.debugMode = debugMode;
        }
    }
}